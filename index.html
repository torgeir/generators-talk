<!doctype html>
<meta charset=utf-8>
<title>es6 generators</title>
<link rel="stylesheet" href="style.css"></link>

<script>
  $ = document.querySelector.bind(document);
  $$ = document.querySelectorAll.bind(document);
</script>

<script src="https://traceur-compiler.googlecode.com/git/bin/traceur.js"></script>
<script src="https://traceur-compiler.googlecode.com/git/src/bootstrap.js"></script>
<script> traceur.options.experimental = true; </script>

<script type="module">
  $$('.code').forEach(el => {
    el.addEventListener('dblclick', () => {
      var script = `console.clear(); ${el.textContent}`;

      var t = new traceur.WebPageTranscoder();
      t.url = 'w.t.f';
      t.addFileFromScriptElement(null, "some-name-"+Math.random(), script);
      t.run();
    }, true);
  });
</script>

<textarea id="source">
layout: true
name: part
class: inverse
---
template: part

# es6 generators

<object class="bartjs" data="http://bartjs.github.io/assets/logo.svg" id="svg" type="image/svg+xml">bartjs</object> 

<a href="http://bit.ly/es6-generators">bit.ly/es6-generators</a>

???

- ny funksjonalitet i es6
- iteratorer og generatorer som en del av språket
- slik det er implementert byr det også på mer interessante bruksområder, enn bare looping

agenda
- først en liten intro til hva det er
- eksempler
- litt demo, koding
- kreativ bruk
- vise en måte å skrive asynkron kode på som man egentlig bare har drømt om i javascript

---
template: part
# what do you need?
---
layout: false
# browser

```html
<!doctype html>
<meta charset=utf-8>
<title>play with es6</title>
<script src="https://traceur-compiler.googlecode.com/git/bin/traceur.js"></script>
<script src="https://traceur-compiler.googlecode.com/git/src/bootstrap.js"></script>
<script> traceur.options.experimental = true; </script>

<script type="module">
  // some es6 code
</script>
```
---
# node

node version >= 0.11.0

```js
node --harmony some-es6-code.js
```

## or

```js
npm install -g traceur
traceur some-es6-code.js
```
---
template: part
# ***,
# a keyword,
# two methods,
# and a loop.

???

nye deler av språket som kommer med generators
- stjerne - brukes i deklarasjonen av en generator
- ett nytt keyword - for å si at en generator skal gi en ny verdi
- to metoder - håndtere flyten i en generator
- en ny type loop, som kan loope alt mulig, også generators
---
.code.code--large.code--transparent.code--center[
  ```js
  function * gen () {
    yield 42;
  }

  var iterator = gen();

  for (var i of iterator) {
    console.log(i);
  }
  ```
]
---
template: part
# return a value and *suspend* a function
# *resume* a function with a value
# throw an exception *into* a function

???

en generator funksjon

- kan som en vanlig funksjon, returnere en verdi
- men funksjonen kan pauses
- contexten lagres, så variabler i scope beholdes, med verdier, etc.
- fortsette en slik funksjon, og senere pauses igjen
- man kan sende en verdi inn til den når den fortsettes
- istedet for å gi den en verdi, kan man kaste en exception inn i funksjonen

---
template: part
# mind *blown*

<img src="mind-blown.gif" style="margin-top: 1em; width: 40%;">

???

- hører det her for første gang

---
template: part
# an example
---
.code.code--large.code--transparent.code--center[
  ```js
  function * gen () {

  }
  ```
]

???

- en generator defineres med `*`

---
.code.code--large.code--transparent.code--center[
  ```js
  function * gen () {
    yield 42;
  }
  ```
]

???

betyr egentlig
- når noen ber om en verdi, kjør til `yield`
- returner 42
- og pause funksjonen

---
.code.code--large.code--transparent.code--center[
  ```js
  var iterator = gen();
  // {
  //   next: [Function],
  //   throw: [Function]
  // }
  ```
]

???

- iteratoren man får når man kaller en generator

---
.code.code--large.code--transparent.code--center[
  ```js
  for (var n of iterator) {
    console.log(n); // 42
  }
  ```
]
---
template: part
# manual iteration
---
.code.code--large.code--transparent.code--center[
  ```js
  function * gen () {
    yield 1;
    yield 2;
    return 42;
  };
  ```
]

???

- en funksjon kan `yield`e flere ganger

---
.code.code--medium.code--transparent.code--center[
  ```js
  var iter = gen();
  ```
]

???

- `gen()` initialiserer iteratoren

--

.code.code--medium.code--transparent.code--center[
  ```js
  iter.next();
  // { value: 1, done: false }
  ```
]

???

- `.next()` kjører til første `yield`
- får ut `value`, det som yield'es
- og en property `done`, som sier om iteratoren er ferdig
- funksjonen pauses helt til man kaller `.next()` igjen

--
.code.code--medium.code--transparent.code--center[
  ```js
  iter.next();
  // { value: 2, done: false }
  ```
]

--
.code.code--medium.code--transparent.code--center[
  ```js
  iter.next();
  // { value: 42, done: true }
  ```
]

???

- iteratoren varsler at den er ferdig, med `done`

--
.code.code--medium.code--transparent.code--center[
  ```js
  iter.next();
  // Error: "next" on closed generator
  //   at ...
  ```
]

???

- `.next()` når den er `done`, så smeller det

---
.code.code--large.code--transparent.code--center[
  ```js
  var iter = gen();
  for (var i of iter) {
    console.log(i);
  }

  // 1
  // 2
  ```
]

???

- for-loopen skjønner iteratorer
- kaller `.next()` til den er `done`
- får bare verdier som er yield'et

---
template: part
# infinite sequences
---
.code.code--medium.code--transparent.code--center[
  ```js
  function natural () {
    var numbers = [];

    var n = 1;
    while (true) {
      numbers.push(n++);
    }

    return numbers;
  }

  // for (var n of natural()) {
  //   console.log(n);
  // }
  ```
]

???

- noe man ikke har kunnet uttrykt i js hittil
- kommer aldri til loopen, der vi vil logge

---
.code.code--medium.code--transparent.code--center[
  ```js
  function * natural () {
    var n = 1;
    while (true) {
      yield n++;
    }
  }

  // for (var n of natural()) {
  //   console.log(n);
  // }
  ```
]

???

- fordi generators er lazy kan vi faktisk gjøre det her
- representert en uendelig sekvens
- hver `.next()` kjører bare til neste yield
- kjører ikke videre før man kaller `.next()` igjen
- fortsatt dårlig suksess i en loop
---
.code.code--medium.code--transparent.code--center[
  ```js
  function * take (n, list) {
    var i = 0;
    for (var x of list) {
      if (n === i++) {
        return;
      }
      yield x;
    }
  }

  for (var n of take(5, natural())) {
    console.log(n);
  }
  // 1
  // 2
  // 3
  // 4
  // 5
  ```
]
---
.code.code--medium.code--transparent.code--center[
  ```js
  function * fibonacci () {
    var n = 0, m = 1;

    while (true) {
      yield n;
      [n, m] = [m, n + m];
    }
  };

  for (var i of take(100, fibonacci())) {
    console.log(i);
  }
  ```
]

???

- tøft?
- men likevel litt ...

---
template: part
# a fibonacci generator

<img src="falling-asleep.gif">

# how *useful*
---
template: part
# *code*
## yield
## .next(value)
## .throw(error)
## asynchronous code?

???

- asynkron kode som ser synkron ut

---
template: part
# mind *blown*

<img src="mind-blown-barny.gif" style="margin-top: 1em; width: 90%;">
---
template: part
# make yield *wait for async operation*
# *return a result* from yield
# throw error into a generator to *handle errors synchronously*

???

- allerede ganske tøft, mind boggling
- men vi kan klare enda bedre?
---
template: part
# sounds like a..

# *promise*?

???

høres ikke det ut som et promise?

- vente på en asynk operasjon
- få tilbake et resultat
- må huske å håndtere feil
- men kan feilhåndteringa bli enda enklere?
---
.code.code--medium.code--transparent.code--center[
  ```js
    var Promise = require('promise');
    var request = require('request');

    function get (url) {

      return new Promise(function (resolve, reject) {

        request(url, function (err, response) {
          if (err) reject(err);
          else resolve(response.body);
        });
      });
    }
  ```
]

???

- en liten recap
- funksjon `get`
- tar en url som parameter
- returnerer et promise
- gjør en request mot url'en
- rejecter det, hvis feil
- resolver det, hvis resultatet (og da med body på responsen)

---
.code.code--medium.code--transparent.code--center[
  ```js
    var vg = get('http://www.vg.no');
    var google = get('http://www.google.com');

    Promise
      .all([vg, google])
      .then(

        function (htmls) {
          console.log(htmls[0].substr(0, 30));
          console.log(htmls[1].substr(0, 30));
        },

        function (error) {
          console.error('something blew up', error);
        });
  ```
]

???

- vent på svar fra `vg.no` og `google.com`
- log begge
- husk å håndter feil

---
template: part
# generators and promises *combined*
---
.code.code--medium.code--transparent.code--center[
  ```js
    async(function * () {

      try {
        var vg = yield get('http://www.vg.no');
        var google = yield get('http://www.google.no');

        console.log('vg', vg.substr(0, 30));
        console.log('google', google.substr(0, 30));
      }
      catch (error) {
        console.error('something blew up', error);
      }
    });
  ```
]

???

- hva om jeg sa at asynkron kode kunne se sånn ut?
- det kan den faktisk!
---
.code.code--medium.code--transparent.code--center[
  ```js
    function async (generator) {
      var iterator = generator();

      function move (result) {
        if (result.done) {
          return result.value;
        }

        return result.value.then(
          function (promiseResult) {
            return move(iterator.next(promiseResult));
          },
          function (promiseError) {
            return move(iterator.throw(promiseError));
          });
      }

      return move(iterator.next());
    }
  ```
]

.footnote[*@*<a href="http://twitter.com/ForbesLindesay" style="color: black">ForbesLindesay</a>]

???

- yielder alltid et promise, så result.value er alltid et promise
- setter inn `promiseResult` som resultat av yield
- fortsetter
- kaster en evt feilmelding tilbake inn i generatoren
- fortsetter
- håndterer evt flere yields
- håndterer evt yield fra en catch
---
template: part
# Generators + Promises *<3*

<img src="happy.jpg" style="margin-top: 1em; max-width: 50%">

# *@*<a href="http://github.com/torgeir/generators-talk" style="color: white">torgeir</a>
---
template: part
.left.pull-left[
## References
- <a href="https://www.youtube.com/watch?v=qbKWsbJ76-s">Forbes Lindsey - Control flow utopia</a>
- <a href="http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/">Why coroutines won’t work on the web</a>
- <a href="https://github.com/then/promise">Promise</a>
- <a href="https://github.com/mikeal/request">Request</a>
- <a href="http://wiki.ecmascript.org/doku.php?id=strawman:async_functions">Async functions</a>
]
.left.pull-right[
## More code
- <a href="https://gist.github.com/torgeir/7527690">gist - synchronous click listener</a>
- <a href="https://gist.github.com/torgeir/7527672">gist - parallel yield</a>
- <a href="https://gist.github.com/torgeir/7625806">gist - list</a>
- <a href="https://gist.github.com/torgeir/7619570">gist - option</a>
- <a href="https://gist.github.com/torgeir/7618372">gist - maybe</a>
]
</textarea>

<script src="http://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript">
</script>
<script type="text/javascript">
  var slideshow = remark.create({
    highlightStyle: 'monokai',
    highlightLanguage: 'no-highlight'
  });
</script>
